"""
Communication protocols between Brain and Brainstem.
Defines data structures for predictions and sensory data exchange.
"""

import json
from typing import List, Optional, Dict, Any
from dataclasses import dataclass, field, asdict
from datetime import datetime


@dataclass
class PredictionPacket:
    """
    A prediction generated by the brain, waiting to be validated against reality.
    """
    expected_sensory: List[float]         # Predicted sensor values
    motor_action: Dict[str, float]        # Motor commands to execute
    confidence: float                     # How certain we are (0.0 to 1.0)
    timestamp: datetime                   # When prediction was made
    sequence_id: int                      # For synchronization with brainstem
    
    # Metadata about how prediction was generated
    traversal_paths: List[List[str]] = field(default_factory=list)  # Node IDs used
    consensus_strength: str = "unknown"   # 'strong', 'weak', 'random'
    thinking_depth: int = 0               # How many traversal steps
    threat_level: str = "normal"          # Threat level during prediction
    traversal_count: int = 0              # Number of traversals completed
    time_budget_used: float = 0.0         # Actual thinking time used
    
    def is_high_confidence(self, threshold: float = 0.7) -> bool:
        """Check if this prediction has high confidence."""
        return self.confidence >= threshold
    
    def add_traversal_path(self, node_ids: List[str]):
        """Add a traversal path used to generate this prediction."""
        self.traversal_paths.append(node_ids.copy())
    
    def get_consensus_info(self) -> Dict[str, any]:
        """Get information about the consensus that generated this prediction."""
        return {
            "paths_count": len(self.traversal_paths),
            "consensus_strength": self.consensus_strength,
            "thinking_depth": self.thinking_depth,
            "confidence": self.confidence
        }
    
    def set_sensory_vector_length(self, length: int, default_value: float = 0.0):
        """Set expected sensory vector to specified length with default values."""
        if len(self.expected_sensory) == 0:  # Only set if not already specified
            self.expected_sensory = [default_value] * length
    
    def to_json(self) -> str:
        """Serialize to JSON for network transmission."""
        data = asdict(self)
        data['timestamp'] = self.timestamp.isoformat()
        return json.dumps(data)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'PredictionPacket':
        """Deserialize from JSON."""
        data = json.loads(json_str)
        data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        return cls(**data)


@dataclass
class SensoryPacket:
    """
    Current sensor readings from the brainstem.
    """
    sensor_values: List[float]            # Raw sensor data [sensor_0, sensor_1, ...]
    actuator_positions: List[float]       # Current actuator states
    timestamp: datetime                   # When readings were taken
    sequence_id: int                      # For synchronization
    
    # Brainstem metadata
    brainstem_prediction: Optional[Dict[str, float]] = None  # Client-side predicted values
    network_latency: float = 0.0          # Measured round-trip time
    
    def get_sensor_count(self) -> int:
        """Get the number of sensors."""
        return len(self.sensor_values)
    
    def get_actuator_count(self) -> int:
        """Get the number of actuators."""
        return len(self.actuator_positions)
    
    def is_sensor_in_range(self, sensor_idx: int, min_val: float, max_val: float) -> bool:
        """Check if a sensor value is within expected range."""
        if 0 <= sensor_idx < len(self.sensor_values):
            return min_val <= self.sensor_values[sensor_idx] <= max_val
        return False
    
    def get_sensor_value(self, sensor_idx: int, default: float = 0.0) -> float:
        """Get a sensor value by index with default fallback."""
        if 0 <= sensor_idx < len(self.sensor_values):
            return self.sensor_values[sensor_idx]
        return default
    
    def calculate_prediction_error(self, predicted_values: List[float]) -> float:
        """Calculate the prediction error against this sensory data."""
        if len(predicted_values) != len(self.sensor_values):
            return float('inf')
        
        # Handle empty arrays
        if len(self.sensor_values) == 0:
            return 0.0
        
        # Calculate RMS error
        error_sum = sum((actual - predicted) ** 2 
                       for actual, predicted in zip(self.sensor_values, predicted_values))
        return (error_sum / len(self.sensor_values)) ** 0.5
    
    def to_json(self) -> str:
        """Serialize to JSON for network transmission."""
        data = asdict(self)
        data['timestamp'] = self.timestamp.isoformat()
        return json.dumps(data)
    
    @classmethod
    def from_json(cls, json_str: str) -> 'SensoryPacket':
        """Deserialize from JSON."""
        data = json.loads(json_str)
        data['timestamp'] = datetime.fromisoformat(data['timestamp'])
        return cls(**data)